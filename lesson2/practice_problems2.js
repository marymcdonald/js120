//q1
function func() {
  return this;
}
let context = func();

console.log(context);

//we have assigned the func function to the variable context and its execution
//context is the global object

/*
answer:
Since line 5 calls func as a function, the implicit context for func is
the global object, so it returns the global object.
*/

//q2
let obj = {
  func: function() {
    return this;
  },
};

let context = obj.func();

console.log(context);

// line 25 has the method call obj.func() and the implicit context for func is
// the caller, the object obj.

/*
answer:
Unlike problem 1, this code outputs the object obj since it invokes func as a
method.
As a method invocation, it receives an implicit execution context that refers
to the object used to invoke it.
*/

//q3
message = 'Hello from the global scope!';

function deliverMessage() {
  console.log(this.message);
}

deliverMessage();

let foo = {
  message: 'Hello from the function scope!',
};

foo.deliverMessage = deliverMessage;

foo.deliverMessage();

// it will first log 'Hello from the global scope!' because deliverMessage() is
// a standalone function and its execution context is the global object.
// then it will log 'Hello from the function scope!' because foo.deliverMessag
// () is a method call invoked by the object foo.

/*
answer:
The first log operation is generated by the function call, deliverMessage() on
line 7. Since this is a function invocation, the implicit function execution
context is the global object; the global property message, which is often
called a global variable, is referenced. The second log operation is generated
by the method call foo.deliverMessage() on line 15. Since the implicit function
execution context for a method invocation is the calling object, this resolves
to foo.message.
*/

//q4
// What built-in methods have we learned about that we can use to specify a
// function's execution context explicitly?

//The methods call and apply

//q5
// Use call to invoke the add method but with foo as execution context. What
// will this return?

let foo = {
  a: 1,
  b: 2,
};

let bar = {
  a: 'abc',
  b: 'def',
  add: function() {
    return this.a + this.b;
  },
};

console.log(bar.add.call(foo));

//this should return 1 + 2 = 3

/*
answer:
Since we invoke call on bar.add with foo as the explicit context, the add
method uses foo.a and foo.b to determine the results, not bar.a and bar.b.
Thus, the return value is 3.
*/